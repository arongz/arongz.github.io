[
  {
    "id": 63277928,
    "slug": "kpad2s",
    "title": "Array.prototype.sort() 方法在不同浏览器间的实现差异",
    "book_id": 24261201,
    "book": {
      "id": 24261201,
      "type": "Book",
      "slug": "noscqk",
      "name": "发布知识库",
      "user_id": 360567,
      "description": "",
      "creator_id": 360567,
      "public": 1,
      "items_count": 2,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-12-23T03:11:45.348Z",
      "updated_at": "2021-12-23T03:11:45.000Z",
      "created_at": "2021-12-23T02:38:18.000Z",
      "namespace": "zhongsr/noscqk",
      "user": {
        "id": 360567,
        "type": "User",
        "login": "zhongsr",
        "name": "寺木",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/360567/1638240872365-avatar/fcfdc251-38c2-4795-a0af-551c2551f1c7.png",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2019-05-28T06:11:40.000Z",
        "updated_at": "2021-12-23T02:44:51.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 360567,
    "creator": {
      "id": 360567,
      "type": "User",
      "login": "zhongsr",
      "name": "寺木",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/360567/1638240872365-avatar/fcfdc251-38c2-4795-a0af-551c2551f1c7.png",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2019-05-28T06:11:40.000Z",
      "updated_at": "2021-12-23T02:44:51.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "Array.prototype.sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的<br />\n<br />由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。<br />\n\n<a name=\"f2b0b493\"></a>\n## 语法\n\n\n```javascript\narr.sort([compareFunction])\n```\n\n\n<a name=\"3d0a2df9\"></a>\n### 参数\n\n<br />compareFunction 可选<br />用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br />firstEl<br />第一个用于比较的元素。<br />secondEl<br />第二个用于比较的元素。<br />返回值<br />排序后的数组。请注意，数组已原地排序，并且不进行复制。<br />\n\n<a name=\"3bdd08ad\"></a>\n### 描述\n\n<br />如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 \"Banana\" 会被排列到 \"cherry\" 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 \"80\" 要比 \"9\" 要靠前。<br />\n<br />如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：<br />\n\n- 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n- 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n- 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br />compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。<br />所以，比较函数格式如下：\n\n\n\n```javascript\nfunction compare(a, b) {\n  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b\n    return -1;\n  }\n  if (a > b ) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}\n```\n\n<br />以上是MDN上面的说明, 但至于各浏览器的具体的实现是没有的.\n<a name=\"ebad8c5e\"></a>\n## 浏览器对compareFunction参数处理的差异\n\n\n```javascript\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b) {\n  return a - b;\n});\nconsole.log(numbers);\n```\n\n<br />直观感觉上 compareFunction 的 a, b 参数应该是, a === numbers[n], b === numbers[n + 1], 但实际上不同浏览器的处理方式却不同, 以下是Chrome 和 Firefox 的处理结果:<br />Chrome<br />\n\n```javascript\n[1,2,3,4,5].sort((a, b)=> {\n  console.log(a, b)\n})\n\n// 2 1  \n// 3 2  \n// 4 3  \n// 5 4\n```\n\n<br />Firefox<br />\n\n```javascript\n[1,2,3,4,5].sort((a,b)=> {\n  console.log(a, b)\n})\n\n// 1 2  \n// 2 3  \n// 3 4  \n// 4 5\n```\n\n<br />由上面结果可以看到, Chrome 和 Firefox compareFunction 的入参方式完全相反.<br />\n<br />这是因为 ES标准 没有规范 compareFunction 传入的参数到底该是什么顺序和算法，只是制定 compareFunction 两数之间的比较规则, 就是上面提到的：<br />\n\n- 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n- 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。\n- 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。\n\n\n<br />明确定义规则后，不管a, b两个数传进来的顺序如何, 只在乎它们两数的排序关系。这就解释了为什么同样的 compareFunction 下，尽管不同浏览器接受的参数不一样，还是能排序出一样的结果。<br />\n<br />参考资料:<br />[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)<br />[https://tc39.es/ecma262/#sec-array.prototype.sort](https://tc39.es/ecma262/#sec-array.prototype.sort)\n",
    "body_draft": "Array.prototype.sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的<br />\n<br />由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。<br />\n\n<a name=\"f2b0b493\"></a>\n## 语法\n\n\n```javascript\narr.sort([compareFunction])\n```\n\n\n<a name=\"3d0a2df9\"></a>\n### 参数\n\n<br />compareFunction 可选<br />用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br />firstEl<br />第一个用于比较的元素。<br />secondEl<br />第二个用于比较的元素。<br />返回值<br />排序后的数组。请注意，数组已原地排序，并且不进行复制。<br />\n\n<a name=\"3bdd08ad\"></a>\n### 描述\n\n<br />如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 \"Banana\" 会被排列到 \"cherry\" 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 \"80\" 要比 \"9\" 要靠前。<br />\n<br />如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：<br />\n\n- 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n- 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n- 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br />compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。<br />所以，比较函数格式如下：\n\n\n\n```javascript\nfunction compare(a, b) {\n  if (a < b ) {           // 按某种排序标准进行比较, a 小于 b\n    return -1;\n  }\n  if (a > b ) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}\n```\n\n<br />以上是MDN上面的说明, 但至于各浏览器的具体的实现是没有的.\n<a name=\"ebad8c5e\"></a>\n## 浏览器对compareFunction参数处理的差异\n\n\n```javascript\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b) {\n  return a - b;\n});\nconsole.log(numbers);\n```\n\n<br />直观感觉上 compareFunction 的 a, b 参数应该是, a === numbers[n], b === numbers[n + 1], 但实际上不同浏览器的处理方式却不同, 以下是Chrome 和 Firefox 的处理结果:<br />Chrome<br />\n\n```javascript\n[1,2,3,4,5].sort((a, b)=> {\n  console.log(a, b)\n})\n\n// 2 1  \n// 3 2  \n// 4 3  \n// 5 4\n```\n\n<br />Firefox<br />\n\n```javascript\n[1,2,3,4,5].sort((a,b)=> {\n  console.log(a, b)\n})\n\n// 1 2  \n// 2 3  \n// 3 4  \n// 4 5\n```\n\n<br />由上面结果可以看到, Chrome 和 Firefox compareFunction 的入参方式完全相反.<br />\n<br />这是因为 ES标准 没有规范 compareFunction 传入的参数到底该是什么顺序和算法，只是制定 compareFunction 两数之间的比较规则, 就是上面提到的：<br />\n\n- 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n- 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。\n- 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。\n\n\n<br />明确定义规则后，不管a, b两个数传进来的顺序如何, 只在乎它们两数的排序关系。这就解释了为什么同样的 compareFunction 下，尽管不同浏览器接受的参数不一样，还是能排序出一样的结果。<br />\n<br />参考资料:<br />[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)<br />[https://tc39.es/ecma262/#sec-array.prototype.sort](https://tc39.es/ecma262/#sec-array.prototype.sort)\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u9111e335\" class=\"ne-p\"><span class=\"ne-text\">Array.prototype.sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</span></p><p id=\"u68a40eea\" class=\"ne-p\"><br></p><p id=\"ua1e221b7\" class=\"ne-p\"><span class=\"ne-text\">由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</span></p><p id=\"u2b25d4c5\" class=\"ne-p\"><br></p><h2 id=\"f2b0b493\"><span class=\"ne-text\">语法</span></h2><p id=\"ued0cd911\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"71dbbfeb\" class=\"ne-codeblock language-javascript\">arr.sort([compareFunction])</pre><p id=\"udd283225\" class=\"ne-p\"><br></p><h3 id=\"3d0a2df9\"><span class=\"ne-text\">参数</span></h3><p id=\"u0f5d00e6\" class=\"ne-p\"><br></p><p id=\"u95c44a98\" class=\"ne-p\"><span class=\"ne-text\">compareFunction 可选<br /></span><span class=\"ne-text\">用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br /></span><span class=\"ne-text\">firstEl<br /></span><span class=\"ne-text\">第一个用于比较的元素。<br /></span><span class=\"ne-text\">secondEl<br /></span><span class=\"ne-text\">第二个用于比较的元素。<br /></span><span class=\"ne-text\">返回值<br /></span><span class=\"ne-text\">排序后的数组。请注意，数组已原地排序，并且不进行复制。</span></p><p id=\"u2f52cc68\" class=\"ne-p\"><br></p><h3 id=\"3bdd08ad\"><span class=\"ne-text\">描述</span></h3><p id=\"u663f791b\" class=\"ne-p\"><br></p><p id=\"u54e935a6\" class=\"ne-p\"><span class=\"ne-text\">如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 &quot;Banana&quot; 会被排列到 &quot;cherry&quot; 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 &quot;80&quot; 要比 &quot;9&quot; 要靠前。</span></p><p id=\"u0d605de4\" class=\"ne-p\"><br></p><p id=\"ua8ca620e\" class=\"ne-p\"><span class=\"ne-text\">如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：</span></p><p id=\"u50f31e9d\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uaab49bff\"><span class=\"ne-text\">如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</span></li><li id=\"u671e950e\"><span class=\"ne-text\">如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</span></li></ul><ul class=\"ne-ul\"><li id=\"uf1368853\"><span class=\"ne-text\">如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br /></span><span class=\"ne-text\">compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。<br /></span><span class=\"ne-text\">所以，比较函数格式如下：</span></li></ul><p id=\"u90361a9b\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"135726fa\" class=\"ne-codeblock language-javascript\">function compare(a, b) {\n  if (a &lt; b ) {           // 按某种排序标准进行比较, a 小于 b\n    return -1;\n  }\n  if (a &gt; b ) {\n    return 1;\n  }\n  // a must be equal to b\n  return 0;\n}</pre><p id=\"u6fda3e5e\" class=\"ne-p\"><br></p><p id=\"u06af1c87\" class=\"ne-p\"><span class=\"ne-text\">以上是MDN上面的说明, 但至于各浏览器的具体的实现是没有的.</span></p><h2 id=\"ebad8c5e\"><span class=\"ne-text\">浏览器对compareFunction参数处理的差异</span></h2><p id=\"u8a43b9f0\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"38843066\" class=\"ne-codeblock language-javascript\">var numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b) {\n  return a - b;\n});\nconsole.log(numbers);</pre><p id=\"u65e617a9\" class=\"ne-p\"><br></p><p id=\"ueb4f3dce\" class=\"ne-p\"><span class=\"ne-text\">直观感觉上 compareFunction 的 a, b 参数应该是, a === numbers[n], b === numbers[n + 1], 但实际上不同浏览器的处理方式却不同, 以下是Chrome 和 Firefox 的处理结果:<br /></span><span class=\"ne-text\">Chrome</span></p><p id=\"ua45f517f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"1367e430\" class=\"ne-codeblock language-javascript\">[1,2,3,4,5].sort((a, b)=&gt; {\n  console.log(a, b)\n})\n\n// 2 1  \n// 3 2  \n// 4 3  \n// 5 4</pre><p id=\"u9b03d260\" class=\"ne-p\"><br></p><p id=\"u844aa838\" class=\"ne-p\"><span class=\"ne-text\">Firefox</span></p><p id=\"uf0f185a9\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"7e370658\" class=\"ne-codeblock language-javascript\">[1,2,3,4,5].sort((a,b)=&gt; {\n  console.log(a, b)\n})\n\n// 1 2  \n// 2 3  \n// 3 4  \n// 4 5</pre><p id=\"u4457c463\" class=\"ne-p\"><br></p><p id=\"u2a6fe41b\" class=\"ne-p\"><span class=\"ne-text\">由上面结果可以看到, Chrome 和 Firefox compareFunction 的入参方式完全相反.</span></p><p id=\"u9aa34d92\" class=\"ne-p\"><br></p><p id=\"u15be36cb\" class=\"ne-p\"><span class=\"ne-text\">这是因为 ES标准 没有规范 compareFunction 传入的参数到底该是什么顺序和算法，只是制定 compareFunction 两数之间的比较规则, 就是上面提到的：</span></p><p id=\"u4e77ef47\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"u446d5688\"><span class=\"ne-text\">如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</span></li><li id=\"u6c8fdc98\"><span class=\"ne-text\">如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</span></li></ul><ul class=\"ne-ul\"><li id=\"ued2fe7c6\"><span class=\"ne-text\">如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</span></li></ul><p id=\"ua36e9a3d\" class=\"ne-p\"><br></p><p id=\"u68c75789\" class=\"ne-p\"><span class=\"ne-text\">明确定义规则后，不管a, b两个数传进来的顺序如何, 只在乎它们两数的排序关系。这就解释了为什么同样的 compareFunction 下，尽管不同浏览器接受的参数不一样，还是能排序出一样的结果。</span></p><p id=\"ub7ed5a0a\" class=\"ne-p\"><br></p><p id=\"u64abddb6\" class=\"ne-p\"><span class=\"ne-text\">参考资料:<br /></span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\" data-href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</span></a><span class=\"ne-text\"><br /></span><a href=\"https://tc39.es/ecma262/#sec-array.prototype.sort\" data-href=\"https://tc39.es/ecma262/#sec-array.prototype.sort\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">https://tc39.es/ecma262/#sec-array.prototype.sort</span></a></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u9111e335\" id=\"u9111e335\"><span data-lake-id=\"u5db68e4e\" id=\"u5db68e4e\">Array.prototype.sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</span></p><p data-lake-id=\"u68a40eea\" id=\"u68a40eea\"><br></p><p data-lake-id=\"ua1e221b7\" id=\"ua1e221b7\"><span data-lake-id=\"udf9d5c71\" id=\"udf9d5c71\">由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</span></p><p data-lake-id=\"u2b25d4c5\" id=\"u2b25d4c5\"><br></p><h2 data-lake-id=\"f2b0b493\" id=\"f2b0b493\"><span data-lake-id=\"ub83846a7\" id=\"ub83846a7\">语法</span></h2><p data-lake-id=\"ued0cd911\" id=\"ued0cd911\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22arr.sort(%5BcompareFunction%5D)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2271dbbfeb%22%7D\"></card><p data-lake-id=\"udd283225\" id=\"udd283225\"><br></p><h3 data-lake-id=\"3d0a2df9\" id=\"3d0a2df9\"><span data-lake-id=\"u65f526bb\" id=\"u65f526bb\">参数</span></h3><p data-lake-id=\"u0f5d00e6\" id=\"u0f5d00e6\"><br></p><p data-lake-id=\"u95c44a98\" id=\"u95c44a98\"><span data-lake-id=\"u4a4861e4\" id=\"u4a4861e4\">compareFunction 可选<br /></span><span data-lake-id=\"uc2a05b7a\" id=\"uc2a05b7a\">用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br /></span><span data-lake-id=\"ua2a91b18\" id=\"ua2a91b18\">firstEl<br /></span><span data-lake-id=\"u7394e279\" id=\"u7394e279\">第一个用于比较的元素。<br /></span><span data-lake-id=\"uf2d5307e\" id=\"uf2d5307e\">secondEl<br /></span><span data-lake-id=\"u541a2f6c\" id=\"u541a2f6c\">第二个用于比较的元素。<br /></span><span data-lake-id=\"u919739da\" id=\"u919739da\">返回值<br /></span><span data-lake-id=\"u435695cf\" id=\"u435695cf\">排序后的数组。请注意，数组已原地排序，并且不进行复制。</span></p><p data-lake-id=\"u2f52cc68\" id=\"u2f52cc68\"><br></p><h3 data-lake-id=\"3bdd08ad\" id=\"3bdd08ad\"><span data-lake-id=\"u28652cde\" id=\"u28652cde\">描述</span></h3><p data-lake-id=\"u663f791b\" id=\"u663f791b\"><br></p><p data-lake-id=\"u54e935a6\" id=\"u54e935a6\"><span data-lake-id=\"ub3259034\" id=\"ub3259034\">如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 &quot;Banana&quot; 会被排列到 &quot;cherry&quot; 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 &quot;80&quot; 要比 &quot;9&quot; 要靠前。</span></p><p data-lake-id=\"u0d605de4\" id=\"u0d605de4\"><br></p><p data-lake-id=\"ua8ca620e\" id=\"ua8ca620e\"><span data-lake-id=\"u428de587\" id=\"u428de587\">如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：</span></p><p data-lake-id=\"u50f31e9d\" id=\"u50f31e9d\"><br></p><ul list=\"u0544b4dc\"><li fid=\"u02d613e9\" data-lake-id=\"uaab49bff\" id=\"uaab49bff\"><span data-lake-id=\"ub20f83af\" id=\"ub20f83af\">如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</span></li><li fid=\"u02d613e9\" data-lake-id=\"u671e950e\" id=\"u671e950e\"><span data-lake-id=\"ud9663e3f\" id=\"ud9663e3f\">如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</span></li><li fid=\"u02d613e9\" data-lake-id=\"uf1368853\" id=\"uf1368853\"><span data-lake-id=\"ua7b147e0\" id=\"ua7b147e0\">如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br /></span><span data-lake-id=\"u8b91f110\" id=\"u8b91f110\">compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。<br /></span><span data-lake-id=\"uf94fbea6\" id=\"uf94fbea6\">所以，比较函数格式如下：</span></li></ul><p data-lake-id=\"u90361a9b\" id=\"u90361a9b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20compare(a%2C%20b)%20%7B%5Cn%20%20if%20(a%20%3C%20b%20)%20%7B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E6%8C%89%E6%9F%90%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%A0%87%E5%87%86%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%2C%20a%20%E5%B0%8F%E4%BA%8E%20b%5Cn%20%20%20%20return%20-1%3B%5Cn%20%20%7D%5Cn%20%20if%20(a%20%3E%20b%20)%20%7B%5Cn%20%20%20%20return%201%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20a%20must%20be%20equal%20to%20b%5Cn%20%20return%200%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22135726fa%22%7D\"></card><p data-lake-id=\"u6fda3e5e\" id=\"u6fda3e5e\"><br></p><p data-lake-id=\"u06af1c87\" id=\"u06af1c87\"><span data-lake-id=\"u513ceedb\" id=\"u513ceedb\">以上是MDN上面的说明, 但至于各浏览器的具体的实现是没有的.</span></p><h2 data-lake-id=\"ebad8c5e\" id=\"ebad8c5e\"><span data-lake-id=\"u6a5625d9\" id=\"u6a5625d9\">浏览器对compareFunction参数处理的差异</span></h2><p data-lake-id=\"u8a43b9f0\" id=\"u8a43b9f0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20numbers%20%3D%20%5B4%2C%202%2C%205%2C%201%2C%203%5D%3B%5Cnnumbers.sort(function(a%2C%20b)%20%7B%5Cn%20%20return%20a%20-%20b%3B%5Cn%7D)%3B%5Cnconsole.log(numbers)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2238843066%22%7D\"></card><p data-lake-id=\"u65e617a9\" id=\"u65e617a9\"><br></p><p data-lake-id=\"ueb4f3dce\" id=\"ueb4f3dce\"><span data-lake-id=\"udac6565c\" id=\"udac6565c\">直观感觉上 compareFunction 的 a, b 参数应该是, a === numbers[n], b === numbers[n + 1], 但实际上不同浏览器的处理方式却不同, 以下是Chrome 和 Firefox 的处理结果:<br /></span><span data-lake-id=\"u9c5fd3f4\" id=\"u9c5fd3f4\">Chrome</span></p><p data-lake-id=\"ua45f517f\" id=\"ua45f517f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5B1%2C2%2C3%2C4%2C5%5D.sort((a%2C%20b)%3D%3E%20%7B%5Cn%20%20console.log(a%2C%20b)%5Cn%7D)%5Cn%5Cn%2F%2F%202%201%20%20%5Cn%2F%2F%203%202%20%20%5Cn%2F%2F%204%203%20%20%5Cn%2F%2F%205%204%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%221367e430%22%7D\"></card><p data-lake-id=\"u9b03d260\" id=\"u9b03d260\"><br></p><p data-lake-id=\"u844aa838\" id=\"u844aa838\"><span data-lake-id=\"u3a6b972b\" id=\"u3a6b972b\">Firefox</span></p><p data-lake-id=\"uf0f185a9\" id=\"uf0f185a9\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5B1%2C2%2C3%2C4%2C5%5D.sort((a%2Cb)%3D%3E%20%7B%5Cn%20%20console.log(a%2C%20b)%5Cn%7D)%5Cn%5Cn%2F%2F%201%202%20%20%5Cn%2F%2F%202%203%20%20%5Cn%2F%2F%203%204%20%20%5Cn%2F%2F%204%205%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%227e370658%22%7D\"></card><p data-lake-id=\"u4457c463\" id=\"u4457c463\"><br></p><p data-lake-id=\"u2a6fe41b\" id=\"u2a6fe41b\"><span data-lake-id=\"ub1dfaf0c\" id=\"ub1dfaf0c\">由上面结果可以看到, Chrome 和 Firefox compareFunction 的入参方式完全相反.</span></p><p data-lake-id=\"u9aa34d92\" id=\"u9aa34d92\"><br></p><p data-lake-id=\"u15be36cb\" id=\"u15be36cb\"><span data-lake-id=\"u33daf8d0\" id=\"u33daf8d0\">这是因为 ES标准 没有规范 compareFunction 传入的参数到底该是什么顺序和算法，只是制定 compareFunction 两数之间的比较规则, 就是上面提到的：</span></p><p data-lake-id=\"u4e77ef47\" id=\"u4e77ef47\"><br></p><ul list=\"ue8a98278\"><li fid=\"u9612c69d\" data-lake-id=\"u446d5688\" id=\"u446d5688\"><span data-lake-id=\"u4b6f9a6f\" id=\"u4b6f9a6f\">如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</span></li><li fid=\"u9612c69d\" data-lake-id=\"u6c8fdc98\" id=\"u6c8fdc98\"><span data-lake-id=\"u4c809ff5\" id=\"u4c809ff5\">如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</span></li><li fid=\"u9612c69d\" data-lake-id=\"ued2fe7c6\" id=\"ued2fe7c6\"><span data-lake-id=\"udc21925f\" id=\"udc21925f\">如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</span></li></ul><p data-lake-id=\"ua36e9a3d\" id=\"ua36e9a3d\"><br></p><p data-lake-id=\"u68c75789\" id=\"u68c75789\"><span data-lake-id=\"u660aa7b9\" id=\"u660aa7b9\">明确定义规则后，不管a, b两个数传进来的顺序如何, 只在乎它们两数的排序关系。这就解释了为什么同样的 compareFunction 下，尽管不同浏览器接受的参数不一样，还是能排序出一样的结果。</span></p><p data-lake-id=\"ub7ed5a0a\" id=\"ub7ed5a0a\"><br></p><p data-lake-id=\"u64abddb6\" id=\"u64abddb6\"><span data-lake-id=\"u84ba9bd9\" id=\"u84ba9bd9\">参考资料:<br /></span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\" target=\"_blank\" data-lake-id=\"ud8d081b7\" id=\"ud8d081b7\"><span data-lake-id=\"u25babf9b\" id=\"u25babf9b\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</span></a><span data-lake-id=\"u1517e1d2\" id=\"u1517e1d2\"><br /></span><a href=\"https://tc39.es/ecma262/#sec-array.prototype.sort\" target=\"_blank\" data-lake-id=\"uce4bc363\" id=\"uce4bc363\"><span data-lake-id=\"u24434430\" id=\"u24434430\">https://tc39.es/ecma262/#sec-array.prototype.sort</span></a></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u9111e335\" id=\"u9111e335\"><span data-lake-id=\"u5db68e4e\" id=\"u5db68e4e\">Array.prototype.sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</span></p><p data-lake-id=\"u68a40eea\" id=\"u68a40eea\"><br></p><p data-lake-id=\"ua1e221b7\" id=\"ua1e221b7\"><span data-lake-id=\"udf9d5c71\" id=\"udf9d5c71\">由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</span></p><p data-lake-id=\"u2b25d4c5\" id=\"u2b25d4c5\"><br></p><h2 data-lake-id=\"f2b0b493\" id=\"f2b0b493\"><span data-lake-id=\"ub83846a7\" id=\"ub83846a7\">语法</span></h2><p data-lake-id=\"ued0cd911\" id=\"ued0cd911\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22arr.sort(%5BcompareFunction%5D)%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2271dbbfeb%22%7D\"></card><p data-lake-id=\"udd283225\" id=\"udd283225\"><br></p><h3 data-lake-id=\"3d0a2df9\" id=\"3d0a2df9\"><span data-lake-id=\"u65f526bb\" id=\"u65f526bb\">参数</span></h3><p data-lake-id=\"u0f5d00e6\" id=\"u0f5d00e6\"><br></p><p data-lake-id=\"u95c44a98\" id=\"u95c44a98\"><span data-lake-id=\"u4a4861e4\" id=\"u4a4861e4\">compareFunction 可选<br /></span><span data-lake-id=\"uc2a05b7a\" id=\"uc2a05b7a\">用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br /></span><span data-lake-id=\"ua2a91b18\" id=\"ua2a91b18\">firstEl<br /></span><span data-lake-id=\"u7394e279\" id=\"u7394e279\">第一个用于比较的元素。<br /></span><span data-lake-id=\"uf2d5307e\" id=\"uf2d5307e\">secondEl<br /></span><span data-lake-id=\"u541a2f6c\" id=\"u541a2f6c\">第二个用于比较的元素。<br /></span><span data-lake-id=\"u919739da\" id=\"u919739da\">返回值<br /></span><span data-lake-id=\"u435695cf\" id=\"u435695cf\">排序后的数组。请注意，数组已原地排序，并且不进行复制。</span></p><p data-lake-id=\"u2f52cc68\" id=\"u2f52cc68\"><br></p><h3 data-lake-id=\"3bdd08ad\" id=\"3bdd08ad\"><span data-lake-id=\"u28652cde\" id=\"u28652cde\">描述</span></h3><p data-lake-id=\"u663f791b\" id=\"u663f791b\"><br></p><p data-lake-id=\"u54e935a6\" id=\"u54e935a6\"><span data-lake-id=\"ub3259034\" id=\"ub3259034\">如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 &quot;Banana&quot; 会被排列到 &quot;cherry&quot; 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 &quot;80&quot; 要比 &quot;9&quot; 要靠前。</span></p><p data-lake-id=\"u0d605de4\" id=\"u0d605de4\"><br></p><p data-lake-id=\"ua8ca620e\" id=\"ua8ca620e\"><span data-lake-id=\"u428de587\" id=\"u428de587\">如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：</span></p><p data-lake-id=\"u50f31e9d\" id=\"u50f31e9d\"><br></p><ul list=\"u0544b4dc\"><li fid=\"u02d613e9\" data-lake-id=\"uaab49bff\" id=\"uaab49bff\"><span data-lake-id=\"ub20f83af\" id=\"ub20f83af\">如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</span></li><li fid=\"u02d613e9\" data-lake-id=\"u671e950e\" id=\"u671e950e\"><span data-lake-id=\"ud9663e3f\" id=\"ud9663e3f\">如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</span></li><li fid=\"u02d613e9\" data-lake-id=\"uf1368853\" id=\"uf1368853\"><span data-lake-id=\"ua7b147e0\" id=\"ua7b147e0\">如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br /></span><span data-lake-id=\"u8b91f110\" id=\"u8b91f110\">compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。<br /></span><span data-lake-id=\"uf94fbea6\" id=\"uf94fbea6\">所以，比较函数格式如下：</span></li></ul><p data-lake-id=\"u90361a9b\" id=\"u90361a9b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20compare(a%2C%20b)%20%7B%5Cn%20%20if%20(a%20%3C%20b%20)%20%7B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E6%8C%89%E6%9F%90%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%A0%87%E5%87%86%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%2C%20a%20%E5%B0%8F%E4%BA%8E%20b%5Cn%20%20%20%20return%20-1%3B%5Cn%20%20%7D%5Cn%20%20if%20(a%20%3E%20b%20)%20%7B%5Cn%20%20%20%20return%201%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20a%20must%20be%20equal%20to%20b%5Cn%20%20return%200%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%22135726fa%22%7D\"></card><p data-lake-id=\"u6fda3e5e\" id=\"u6fda3e5e\"><br></p><p data-lake-id=\"u06af1c87\" id=\"u06af1c87\"><span data-lake-id=\"u513ceedb\" id=\"u513ceedb\">以上是MDN上面的说明, 但至于各浏览器的具体的实现是没有的.</span></p><h2 data-lake-id=\"ebad8c5e\" id=\"ebad8c5e\"><span data-lake-id=\"u6a5625d9\" id=\"u6a5625d9\">浏览器对compareFunction参数处理的差异</span></h2><p data-lake-id=\"u8a43b9f0\" id=\"u8a43b9f0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20numbers%20%3D%20%5B4%2C%202%2C%205%2C%201%2C%203%5D%3B%5Cnnumbers.sort(function(a%2C%20b)%20%7B%5Cn%20%20return%20a%20-%20b%3B%5Cn%7D)%3B%5Cnconsole.log(numbers)%3B%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%2238843066%22%7D\"></card><p data-lake-id=\"u65e617a9\" id=\"u65e617a9\"><br></p><p data-lake-id=\"ueb4f3dce\" id=\"ueb4f3dce\"><span data-lake-id=\"udac6565c\" id=\"udac6565c\">直观感觉上 compareFunction 的 a, b 参数应该是, a === numbers[n], b === numbers[n + 1], 但实际上不同浏览器的处理方式却不同, 以下是Chrome 和 Firefox 的处理结果:<br /></span><span data-lake-id=\"u9c5fd3f4\" id=\"u9c5fd3f4\">Chrome</span></p><p data-lake-id=\"ua45f517f\" id=\"ua45f517f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5B1%2C2%2C3%2C4%2C5%5D.sort((a%2C%20b)%3D%3E%20%7B%5Cn%20%20console.log(a%2C%20b)%5Cn%7D)%5Cn%5Cn%2F%2F%202%201%20%20%5Cn%2F%2F%203%202%20%20%5Cn%2F%2F%204%203%20%20%5Cn%2F%2F%205%204%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%221367e430%22%7D\"></card><p data-lake-id=\"u9b03d260\" id=\"u9b03d260\"><br></p><p data-lake-id=\"u844aa838\" id=\"u844aa838\"><span data-lake-id=\"u3a6b972b\" id=\"u3a6b972b\">Firefox</span></p><p data-lake-id=\"uf0f185a9\" id=\"uf0f185a9\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5B1%2C2%2C3%2C4%2C5%5D.sort((a%2Cb)%3D%3E%20%7B%5Cn%20%20console.log(a%2C%20b)%5Cn%7D)%5Cn%5Cn%2F%2F%201%202%20%20%5Cn%2F%2F%202%203%20%20%5Cn%2F%2F%203%204%20%20%5Cn%2F%2F%204%205%22%2C%22autoWrap%22%3Afalse%2C%22heightLimit%22%3Atrue%2C%22theme%22%3A%22default%22%2C%22id%22%3A%227e370658%22%7D\"></card><p data-lake-id=\"u4457c463\" id=\"u4457c463\"><br></p><p data-lake-id=\"u2a6fe41b\" id=\"u2a6fe41b\"><span data-lake-id=\"ub1dfaf0c\" id=\"ub1dfaf0c\">由上面结果可以看到, Chrome 和 Firefox compareFunction 的入参方式完全相反.</span></p><p data-lake-id=\"u9aa34d92\" id=\"u9aa34d92\"><br></p><p data-lake-id=\"u15be36cb\" id=\"u15be36cb\"><span data-lake-id=\"u33daf8d0\" id=\"u33daf8d0\">这是因为 ES标准 没有规范 compareFunction 传入的参数到底该是什么顺序和算法，只是制定 compareFunction 两数之间的比较规则, 就是上面提到的：</span></p><p data-lake-id=\"u4e77ef47\" id=\"u4e77ef47\"><br></p><ul list=\"ue8a98278\"><li fid=\"u9612c69d\" data-lake-id=\"u446d5688\" id=\"u446d5688\"><span data-lake-id=\"u4b6f9a6f\" id=\"u4b6f9a6f\">如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</span></li><li fid=\"u9612c69d\" data-lake-id=\"u6c8fdc98\" id=\"u6c8fdc98\"><span data-lake-id=\"u4c809ff5\" id=\"u4c809ff5\">如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</span></li><li fid=\"u9612c69d\" data-lake-id=\"ued2fe7c6\" id=\"ued2fe7c6\"><span data-lake-id=\"udc21925f\" id=\"udc21925f\">如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</span></li></ul><p data-lake-id=\"ua36e9a3d\" id=\"ua36e9a3d\"><br></p><p data-lake-id=\"u68c75789\" id=\"u68c75789\"><span data-lake-id=\"u660aa7b9\" id=\"u660aa7b9\">明确定义规则后，不管a, b两个数传进来的顺序如何, 只在乎它们两数的排序关系。这就解释了为什么同样的 compareFunction 下，尽管不同浏览器接受的参数不一样，还是能排序出一样的结果。</span></p><p data-lake-id=\"ub7ed5a0a\" id=\"ub7ed5a0a\"><br></p><p data-lake-id=\"u64abddb6\" id=\"u64abddb6\"><span data-lake-id=\"u84ba9bd9\" id=\"u84ba9bd9\">参考资料:<br /></span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\" target=\"_blank\" data-lake-id=\"ud8d081b7\" id=\"ud8d081b7\"><span data-lake-id=\"u25babf9b\" id=\"u25babf9b\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</span></a><span data-lake-id=\"u1517e1d2\" id=\"u1517e1d2\"><br /></span><a href=\"https://tc39.es/ecma262/#sec-array.prototype.sort\" target=\"_blank\" data-lake-id=\"uce4bc363\" id=\"uce4bc363\"><span data-lake-id=\"u24434430\" id=\"u24434430\">https://tc39.es/ecma262/#sec-array.prototype.sort</span></a></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-12-23T03:11:45.000Z",
    "deleted_at": null,
    "created_at": "2021-12-23T02:44:51.000Z",
    "updated_at": "2021-12-23T03:11:45.000Z",
    "published_at": "2021-12-23T03:11:45.000Z",
    "first_published_at": "2021-12-23T02:44:58.000Z",
    "word_count": 916,
    "cover": null,
    "description": "Array.prototype.sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。语法arr.sort([compareFunction])...",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 63277861,
    "slug": "egs2e3",
    "title": "同步A",
    "book_id": 24261201,
    "book": {
      "id": 24261201,
      "type": "Book",
      "slug": "noscqk",
      "name": "发布知识库",
      "user_id": 360567,
      "description": "",
      "creator_id": 360567,
      "public": 1,
      "items_count": 2,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2021-12-23T02:44:58.957Z",
      "updated_at": "2021-12-23T02:44:59.000Z",
      "created_at": "2021-12-23T02:38:18.000Z",
      "namespace": "zhongsr/noscqk",
      "user": {
        "id": 360567,
        "type": "User",
        "login": "zhongsr",
        "name": "寺木",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/360567/1638240872365-avatar/fcfdc251-38c2-4795-a0af-551c2551f1c7.png",
        "books_count": 2,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2019-05-28T06:11:40.000Z",
        "updated_at": "2021-12-23T02:44:51.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 360567,
    "creator": {
      "id": 360567,
      "type": "User",
      "login": "zhongsr",
      "name": "寺木",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2021/png/360567/1638240872365-avatar/fcfdc251-38c2-4795-a0af-551c2551f1c7.png",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2019-05-28T06:11:40.000Z",
      "updated_at": "2021-12-23T02:44:51.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "A\n",
    "body_draft": "A\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u8c7c59a2\" class=\"ne-p\"><span class=\"ne-text\">A</span></p></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u8c7c59a2\" id=\"u8c7c59a2\"><span data-lake-id=\"uf7b53003\" id=\"uf7b53003\">A</span></p>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><p data-lake-id=\"u8c7c59a2\" id=\"u8c7c59a2\"><span data-lake-id=\"uf7b53003\" id=\"uf7b53003\">A</span></p>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2021-12-23T02:44:40.000Z",
    "deleted_at": null,
    "created_at": "2021-12-23T02:44:19.000Z",
    "updated_at": "2021-12-23T02:44:42.000Z",
    "published_at": "2021-12-23T02:44:40.000Z",
    "first_published_at": "2021-12-23T02:44:40.000Z",
    "word_count": 1,
    "cover": null,
    "description": "A",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  }
]